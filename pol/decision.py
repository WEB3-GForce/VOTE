from printable_object import PrintableObject
import operator

"""
File Generated by Lisp2Python Translator
"""

class Decision(PrintableObject):

    """"
    An object for storing decisions on a bill.
    """

    def __init__(self, for_stances, agn_stances, neg_for_stances, neg_agn_stances,
                 con_rel_for_stances, con_rel_agn_stances, no_update,
                 number_for, number_agn, group_for, group_agn, for_norms,
                 agn_norms, for_bnorms, agn_bnorms, split_group, split_record,
                 split_credo, MI_stance, MI_group, MI_credo, MI_record, MI_norm,
                 strategy, result, reason, downside, downside_record,
                 deeper_analysis, real_vote, score):

        """
        Constructs a new Decision object.

        for_stances         -- list of stances in favor
        agn_stances         -- list of stances opposed
        neg_for_stances     -- list of flip stances in favor
        neg_agn_stances     -- list of flip stances opposed
        con_rel_for_stances -- list of stances in favor by opposition
        con_rel_agn_stances -- list of stances opposed by opposition
        no_update           -- T until update-decision-metrics done
        number_for          -- number of reasons for
        number_agn          -- number of reasons agn
        group_for           -- list of groups in support
        group_agn           -- list of groups opposed
        for_norms           -- norms associated with for stances
        agn_norms           -- norms associated with agn stances
        for_bnorms          -- norms associated with bill's for stances
        agn_bnorms          -- norms associated with bill's agn stances
        split_group         -- list of groups on both sides
        split_record        -- t/nil if voting record is split
        split_credo         -- t/nil if own credo is split
        MI_stance           -- for/agn/nil -- >important? for agn
        MI_group            -- for/agn/nil
        MI_credo            -- for/agn/nil
        MI_record           -- for/agn/nil
        MI_norm             -- for/agn/nil
        strategy            -- decision strategy used to arrive at result
        result              -- for/agn -- position arrived at
        reason              -- support for position
        downside            -- negative aspects of decision
        downside_record     -- voting record stances supporting downside
        deeper_analysis     -- set by deeper-analysis strategy
        real_vote           -- actual vote for test bills
        score               -- accuracy of predicted vote

        return              -- returns nothing
        """
        self.isa_depth = isa_depth
        self.sort_key = sort_key
        self.bill = bill
        self.member = member
        self.for_stances = for_stances
        self.agn_stances = agn_stances
        self.neg_for_stances = neg_for_stances
        self.neg_agn_stances = neg_agn_stances
        self.con_rel_for_stances = con_rel_for_stances
        self.con_rel_agn_stances = con_rel_agn_stances
        self.no_update = no_update
        self.number_for = number_for
        self.number_agn = number_agn
        self.group_for = group_for
        self.group_agn = group_agn
        self.for_norms = for_norms
        self.agn_norms = agn_norms
        self.for_bnorms = for_bnorms
        self.agn_bnorms = agn_bnorms
        self.split_group = split_group
        self.split_record = split_record
        self.split_credo = split_credo
        self.MI_stance = MI_stance
        self.MI_group = MI_group
        self.MI_credo = MI_credo
        self.MI_record = MI_record
        self.MI_norm = MI_norm
        self.strategy = strategy
        self.result = result
        self.reason = reason
        self.downside = downside
        self.downside_record = downside_record
        self.deeper_analysis = deeper_analysis
        self.real_vote = real_vote
        self.score = score

    def update_decision_metrics(self):
        fors   = self.for_stances
        agns   = self.agn_stances
        billid = self.bill
        bill   = DBBill.getById(billid)
        
        self.number_for = len(fors)
        self.number_agn = len(agns)
        
        self.for_bnorms = check_norms(bill.stance_for)
        self.agn_bnorms = check_norms(bill.stance_agn)

        self.for_norms = check_norms(fors)
        self.agn_norms = check_norms(agns)
        
        self.group_for = collect_groups(fors)
        self.group_agn = collect_groups(agns)
        
        self.split_group = find_intersection(self.group_for, self.group_ag, operator.eq)

        self.split_record = None
        for_bills = collect_bills(fors)
        agn_bills = collect_bills(agns)
        
        # Lisp syntax would have just have assigned this as
        # the agn_bills. I decided to do this to be able to
        # show all data. I think this is simply a matter of
        # is nil versus assigned.
        if for_bills and agn_bills:
            self.split_record = for_bills + agn_bills
        
        self.split_credo = None
        for_credo = collect_credo(fors)
        agn_credo = collect_credo(agns)       

        if for_credo and agn_credo:
            self.split_credo = for_cred + agn_credo
            
        self.update_MI_stances()
        self.no_update = None

    def update_MI_stances(self):
        self.MI_stance = self.MI_stance()
        self.MI_group  = self.MI_stance("GROUP")
        self.MI_credo  = self.MI_stance("MEMBER") 
        self.MI_record  = self.MI_stance("BILL")
        self.MI_norm  = compare_stances(self.for_norms, self.agn_norms)
    
    def MI_stances(self, db_type=None):
        fors = self.for_stances
        agns = self.agn_stances
        
        if db_type:
            fors = collect_source_type(db_type, fors)
            agns = collect_source_type(db_type, agns)
        compare_stances(fors, agns)
    


def collect_groups(stances)
    return collect_source_type("GROUP", stances)

def collect_credo(stances)
    return collect_source_type("MEMBER", stances)

def collect_bills(stances)
    return collect_source_type("BILL", stances)

def collect_source_type(db, stances)
    filter_fun = lambda stance : stance.source_db == db
    return filter(filter_fun, stances)

def check_norms(stances)
    filter_fun = lambda stance: normative_stance?(stance)
    norms = filter(filter_fun, stances)
    if norms:
        return remove_duplicates(norms)

def compare_stances(fors, agns):

    fors.sort(key=lambda stance: stance.importance)
    agns.sort(key=lambda stance: stance.importance)

    for a_for, an_agn in map(None, fors, agns):
        if not a_for and not an_agn:
            return None
        elif not a_for:
            return ["AGN", remove_less_important(agns)]
        elif not an_agn:
            return ["FOR", remove_less_important(fors)]
        elif greater_than_importance?(a_for,an_agn):
            return ["FOR", remove_less_important(fors)]
        elif less_than_importance?(a_for, an_agn):
            return ["AGN", remove_less_important(agns)]

    return None

def remove_less_important(stances):
    filter_fun = lambda stance : not less_than_importance?(stance, stances[0])
    return filter(filter_fun, stances)

def normative_stance?(stance)
    norm = DBIssue.GetById(stance.issue).norm
    # Here, they have a match? function. Check this out later
    # if you need to do something specific. For now, just
    # assume that it is fine. Check after you have done
    # DB modeling

    if norm:
        return stance == norm
    
